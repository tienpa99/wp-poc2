{"version":3,"file":"queue.lite.js","mappings":"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","sources":["webpack://devowl-local-files/real-cookie-banner/default-lite/webpack/bootstrap","webpack://devowl-local-files/real-cookie-banner/default-lite/webpack/runtime/compat get default export","webpack://devowl-local-files/real-cookie-banner/default-lite/webpack/runtime/define property getters","webpack://devowl-local-files/real-cookie-banner/default-lite/webpack/runtime/hasOwnProperty shorthand","webpack://devowl-local-files/real-cookie-banner/default-lite/webpack/runtime/make namespace object","webpack://devowl-local-files/real-cookie-banner/default-lite/external var \"devowlWp_utils\"","webpack://devowl-local-files/real-cookie-banner/default-lite/external var \"devowlWp_realQueue\"","webpack://devowl-local-files/real-cookie-banner/default-lite/src/types/queue.tsx","webpack://devowl-local-files/real-cookie-banner/default-lite/src/utils/i18n.tsx","webpack://devowl-local-files/real-cookie-banner/default-lite/external var \"jQuery\"","webpack://devowl-local-files/real-cookie-banner/default-lite/src/wp-api/scannerQueue.post.tsx","webpack://devowl-local-files/real-cookie-banner/default-lite/internal/sitemap-crawler@0.2.18/utils/mapUrlToRootUrl.tsx","webpack://devowl-local-files/real-cookie-banner/default-lite/internal/sitemap-crawler@0.2.18/findByRobots.tsx","webpack://devowl-local-files/real-cookie-banner/default-lite/internal/sitemap-crawler@0.2.18/findByKnownFilenames.tsx","webpack://devowl-local-files/real-cookie-banner/default-lite/internal/sitemap-crawler@0.2.18/crawl.tsx","webpack://devowl-local-files/real-cookie-banner/default-lite/internal/sitemap-crawler@0.2.18/parse.tsx","webpack://devowl-local-files/real-cookie-banner/default-lite/src/others/scanner/crawlSitemap.tsx","webpack://devowl-local-files/real-cookie-banner/default-lite/internal/sitemap-crawler@0.2.18/find.tsx","webpack://devowl-local-files/real-cookie-banner/default-lite/src/queue.tsx","webpack://devowl-local-files/real-cookie-banner/default-lite/src/others/scanner/execute.tsx","webpack://devowl-local-files/real-cookie-banner/default-lite/src/others/scanner/listenStatus.tsx","webpack://devowl-local-files/real-cookie-banner/default-lite/src/others/scanner/automaticScanStarter.tsx"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = devowlWp_utils;","const __WEBPACK_NAMESPACE_OBJECT__ = devowlWp_realQueue;","const SCAN_QUEUE_JOB = \"rcb-scan\";\nconst AUTOMATIC_SCAN_STATER_QUEUE_JOB = \"rcb-automatic-scan-starter\";\nexport { SCAN_QUEUE_JOB, AUTOMATIC_SCAN_STATER_QUEUE_JOB };","/* istanbul ignore file: this file does not contain any logic, only factory calls */\n\nimport { createLocalizationFactory, BaseOptions } from \"@devowl-wp/utils\";\n\n// Only needed once per `window`\nlet FACTORY_MEMO;\nfunction get() {\n  return FACTORY_MEMO ? FACTORY_MEMO : FACTORY_MEMO = createLocalizationFactory(BaseOptions.getPureSlug(process.env.slug));\n}\nconst _n = function () {\n  return get()._n(...arguments);\n};\nconst _nx = function () {\n  return get()._nx(...arguments);\n};\nconst _x = function () {\n  return get()._x(...arguments);\n};\nconst __ = function () {\n  return get().__(...arguments);\n};\nconst _i = function () {\n  return get()._i(...arguments);\n};\nexport { _n, _nx, _x, __, _i };","const __WEBPACK_NAMESPACE_OBJECT__ = jQuery;","import { RouteHttpVerb } from \"@devowl-wp/utils\";\nexport const locationRestScannerQueuePost = {\n  path: \"/scanner/queue\",\n  method: RouteHttpVerb.POST\n};","/**\n * @see https://stackoverflow.com/a/6944961/5506547\n * @see https://regex101.com/r/wLTlSe/1\n */\nconst REGEXP_URL_PATH = /.+?:\\/\\/.+?(\\/.+?)(?:#|\\?(.*)|$)/;\n\n/**\n * Get path of (sitemap) URL as we do not rely on the received host.\n *\n * - site got cloned with WP Duplicator -> wrong host in robots.txt if not yet flushed\n * - General > Settings is configured with `http` but site is served with `https`\n */\nfunction mapUrlToRootUrl(rootUrl, receivedUrl) {\n  let query = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  const rootUrlPath = rootUrl.match(REGEXP_URL_PATH)?.[1] || \"/\";\n  const match = receivedUrl.match(REGEXP_URL_PATH);\n  if (match) {\n    const [, path, receivedQuery] = match; // e.g. `/sitemap.xml`, `my-param=1`\n    const useQuery = receivedQuery ? `?${receivedQuery}${query ? `?${query}` : \"\"}` : query ? `?${query}` : \"\";\n    return `${rootUrl}${path.substr(rootUrlPath.length)}${useQuery}`;\n  }\n  return false;\n}\nexport { mapUrlToRootUrl };","import { mapUrlToRootUrl } from \"./utils\";\nconst ROBOTS_TXT = \"robots.txt\";\n\n/**\n * Look for a valid `robots.txt` and parse `Sitemap` url.\n *\n * @see https://regex101.com/r/Trn97e/1\n * @param forceSitemapArgument Append this query argument to the `robots.txt` in case you can server-side activate the sitemap\n */\nasync function findByRobots(url, forceSitemapArgument) {\n  try {\n    const query = forceSitemapArgument ? `${forceSitemapArgument}=1` : \"\";\n    const response = await fetch(`${url}${ROBOTS_TXT}${query ? `?${query}` : \"\"}`);\n    if (!response.ok) {\n      return false;\n    }\n    const content = await response.text();\n    const sitemapUrl = content.match(/^sitemap:(.*)$/im)[1].trim();\n    const correctedSitemapUrl = mapUrlToRootUrl(url, sitemapUrl, query);\n    if (correctedSitemapUrl) {\n      // Check if sitemap really exists and isn't stale (e.g. deactivate RankMath SEO WP plugin does not recreate robots.txt)\n      const responseCheckSitemap = await fetch(correctedSitemapUrl);\n      if (!responseCheckSitemap.ok) {\n        return false;\n      }\n\n      // Scenario: Sitemap does not exist but a plugin redirects directly to the homepage => no error code\n      const body = await responseCheckSitemap.text();\n      if (!/<(?:sitemap|urlset)/gm.test(body)) {\n        return false;\n      }\n      return correctedSitemapUrl;\n    }\n    return false;\n  } catch (e) {\n    return false;\n  }\n}\nexport { findByRobots };","const KNOWN_FILENAMES = [\"sitemap.xml\", \"sitemap_index.xml\", \"sitemap-index.xml\", \"sitemap/\", \"post-sitemap.xml\", \"sitemap/sitemap.xml\", \"sitemap/index.xml\", \"sitemapindex.xml\", \"sitemap.php\", \"sitemap.txt\", \"index.php/sitemap_index.xml\", \"index.php?xml_sitemap=params=\", \"glossar/sitemap.xml\"];\n\n/**\n * Look known sitemap URLs when it is not yet filled in the `robots.txt`.\n *\n * @see https://pagedart.com/blog/how-to-find-the-sitemap-of-a-website/#manually\n */\nasync function findByKnownFilenames(root) {\n  let tryKnownFilenames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : KNOWN_FILENAMES;\n  const promises = tryKnownFilenames.map(filename => fetch(`${root}${filename}`, {\n    // Do not throw an error for failed CORS requests, instead we expect an empty response\n    mode: \"no-cors\"\n  }));\n  for (const promise of promises) {\n    try {\n      const response = await promise;\n      const responseBody = await response.text();\n\n      // We do not rely on `fetch.ok` cause e.g. RankMath forces `404` error code even the sitemap is rendered\n      if (responseBody.indexOf(\"<sitemapindex\") > -1 || responseBody.indexOf(\"<urlset\") > -1) {\n        return response.url;\n      }\n    } catch (e) {\n      // Silence is golden.\n    }\n  }\n  return false;\n}\nexport { findByKnownFilenames };","import { parse } from \".\";\nimport { mapUrlToRootUrl } from \"./utils\";\n\n/**\n * Use pseudo base so e.g. sitemaps configured as `/sitemap.xml` (relative) configured\n * in `robots.txt` are parsed correctly.\n */\nconst PSEUDO_URL_BASE = \"https://base\";\nasync function crawl(rootUrl, sitemapUrl, sites) {\n  if (!sites) {\n    // Initial crawl\n    try {\n      return (await crawl(rootUrl, sitemapUrl, [])).sort((a, b) => a.length - b.length);\n    } catch (e) {\n      // Atm we are ignoring errors\n      console.error(e);\n      return [];\n    }\n  } else {\n    try {\n      const document = await parse(sitemapUrl);\n      const {\n        protocol: sitemapProtocol\n      } = new URL(sitemapUrl, PSEUDO_URL_BASE);\n\n      // Check if sitemap is an index of multiple sitemaps\n      const sitemapIndex = document.querySelector(\"sitemapindex\");\n      if (sitemapIndex) {\n        const indexUrls = Array.from(sitemapIndex.children).map(c => c.querySelector(\"loc\")?.textContent)\n        // In some cases, the `DOMParser` can return `parsererror` children, we need to skip\n        // them as the other `sitemap` children are still correctly parsed\n        .filter(Boolean);\n\n        // Iterate sequentially instead of concurrent as we are in a browser and we should avoid parallel requests here (CloudFlare Bots etc.)\n        for (const indexUrl of indexUrls) {\n          const useUrl = mapUrlToRootUrl(rootUrl, indexUrl) || indexUrl;\n          await crawl(rootUrl, useUrl, sites);\n        }\n      }\n\n      // Check for URL set (we finally found an URL!)\n      const urlSet = document.querySelector(\"urlset\");\n      if (urlSet) {\n        const urls = Array.from(urlSet.children).map(c => c.querySelector(\"loc\")?.textContent).filter(Boolean).map(url => {\n          try {\n            const urlInstance = new URL(url, PSEUDO_URL_BASE);\n            if (urlInstance.protocol === \"http:\") {\n              urlInstance.protocol = sitemapProtocol;\n            }\n            return urlInstance.toString();\n          } catch (e) {\n            // Silence is golden.\n            return url;\n          }\n        });\n\n        // Not needed atm cause WordPress and plugins force the protocol correctly here\n        //.map((url) => mapUrlToRootUrl(rootUrl, url) || url);\n        sites.push(...urls);\n      }\n    } catch (e) {\n      console.error(`Error occurred during \"crawl('${sitemapUrl}')\":\\n\\r Error: ${e}`);\n    }\n  }\n  return sites;\n}\nexport { crawl };","async function parse(sitemapUrl) {\n  const response = await fetch(sitemapUrl);\n  const body = await response.text();\n  return new DOMParser().parseFromString(body.trim(), \"application/xml\");\n}\nexport { parse };","import { __ } from \"../../utils\";\nimport { crawl, findSitemap } from \"@devowl-wp/sitemap-crawler\";\nasync function crawlSitemap(setStep) {\n  const textOfferSupport = __('If you think a sitemap exists but you get this error, please <a href=\"%s\" target=\"_blank\" />contact our support</a> and we will look individually where the problem is in your WordPress installation.', __(\"https://devowl.io/support/\"));\n\n  // Use original `home_url` to support WordPress installations within a subfolder (https://git.io/JRM9g)\n  let rootUrl = window.realCookieBannerQueue.originalHomeUrl;\n  rootUrl = rootUrl.split(\"?\", 2)[0];\n  setStep?.(\"find-sitemap\");\n  const sitemapUrl = await findSitemap(rootUrl, \"rcb-force-sitemap\", [\"?sitemap=index&rcb-force-sitemap=1\"]);\n  if (sitemapUrl === false) {\n    throw new Error(`${__(\"We didn't find a sitemap on your website. We need it to scan all the subpages of your website. Do you have this feature disabled in your WordPress?\")} ${textOfferSupport}`);\n  }\n  setStep?.(\"collect-sitemap\");\n  let sites = [];\n  try {\n    sites = await crawl(rootUrl, sitemapUrl);\n  } catch (e) {\n    throw new Error(`${__(\"The sitemap could not be parsed. Therefore, we cannot check for services on your website.\")} ${textOfferSupport}`);\n  }\n  if (sites.length === 0) {\n    throw new Error(`${__(\"The sitemap is empty. So, we could not add any URLs to the scanner.\")} ${textOfferSupport}`);\n  }\n  return sites;\n}\nexport { crawlSitemap };","import { findByRobots, findByKnownFilenames } from \".\";\n\n/**\n * Find sitemap URL by different methods.\n *\n * @param rootUrl The root URL of your current website (with leading `/`!)\n * @param forceSitemapArgument See `findByRobots`\n */\nfunction findSitemap(rootUrl, forceSitemapArgument, tryKnownFilenames) {\n  return new Promise((resolve, reject) => {\n    /**\n     * We need to wrap the resolving mechanism in an additional non-blocking `setTimeout`.\n     * Why? Requesting a lot of wrong URLs with `findByKnownFilenames` could lead to a race\n     * condition within browsers and their Race Cache With Network (RCWN).\n     *\n     * Without this, this could lead to wrong error messages when requesting the found sitemap URL\n     * again, e.g. with `crawl`.\n     */\n    const resolver = result => setTimeout(() => resolve(result), 100);\n    (async () => {\n      try {\n        // 1. `robots.txt`\n        const robotsTxt = await findByRobots(rootUrl);\n        if (robotsTxt) {\n          resolver(robotsTxt);\n          return;\n        }\n\n        // 2. Known filenames\n        const byKnownFilenames = await findByKnownFilenames(rootUrl);\n        if (byKnownFilenames) {\n          resolver(byKnownFilenames);\n          return;\n        }\n\n        // 3. Force and activate `robots.txt` and sitemaps in WordPress itself\n        // e.g. when the setting of visibility is activated in Settings > Reading\n        // 1. `robots.txt`\n        if (forceSitemapArgument) {\n          const robotsTxtForce = await findByRobots(rootUrl, forceSitemapArgument);\n          if (robotsTxtForce) {\n            resolver(robotsTxtForce);\n            return;\n          }\n        }\n\n        // 4. Try another set of known filenames\n        if (tryKnownFilenames) {\n          const byKnownFilenamesCustom = await findByKnownFilenames(rootUrl, tryKnownFilenames);\n          if (byKnownFilenamesCustom) {\n            resolver(byKnownFilenamesCustom);\n            return;\n          }\n        }\n        resolver(false);\n      } catch (e) {\n        reject(e);\n      }\n    })();\n  });\n}\nexport { findSitemap };","/* istanbul ignore file: we do not need to care about the entry point file as errors are detected through integration tests (E2E) */\n\nimport { handleCorruptRestApi } from \"@devowl-wp/utils\";\nimport { listenScannerJobExecution, listenScannerStatus, listenAutomaticScanStarterJobExecution } from \"./others\";\n\n/**\n * The entry point for the `real-queue` workers\n */\n\nhandleCorruptRestApi({\n  // We do not have checks for this REST API as it should be solved by real-cookie-banner itself\n});\nlistenScannerJobExecution();\nlistenScannerStatus();\nlistenAutomaticScanStarterJobExecution();","import { CLIENT_JOB_EVENT_PREFIX, JOB_DELAY_EVENT_PREFIX, fetchStatus } from \"@devowl-wp/real-queue\";\nimport { applyQueryString } from \"@devowl-wp/utils\";\nimport { SCAN_QUEUE_JOB } from \"../../types\";\n\n/**\n * Add listener for the scanner status and automatically update the UI.\n */\nfunction listenScannerJobExecution() {\n  document.addEventListener(`${JOB_DELAY_EVENT_PREFIX}${SCAN_QUEUE_JOB}`, _ref => {\n    let {\n      detail: {\n        isIdle,\n        settings\n      }\n    } = _ref;\n    const isInScannerTab = /page=real-cookie-banner(?:-pro)?-component#\\/scanner/.test(window.location.href);\n    settings.delay_ms = isInScannerTab || isIdle ? settings.delay_ms : 3000;\n  });\n  document.addEventListener(`${CLIENT_JOB_EVENT_PREFIX}${SCAN_QUEUE_JOB}`, _ref2 => {\n    let {\n      detail: {\n        job: {\n          id,\n          data: {\n            url\n          },\n          process_total,\n          group_position,\n          group_total,\n          group_uuid\n        },\n        resolve,\n        reject,\n        saveJobResult\n      }\n    } = _ref2;\n    const executeThis = async url => {\n      const finalUrl = new URL(url);\n\n      // Do not modify the URL when it e.g. is a redirection and has already the correct query parameters\n      // Who knows? Perhaps a webserver redirects to a A-Z ordered query list?!\n      const {\n        searchParams\n      } = finalUrl;\n      const hasAlreadyCorrectParams = searchParams.get(\"rcb-scan\") === \"1\" && searchParams.get(\"rcb-scan-job\") === `${id}`;\n      if (!hasAlreadyCorrectParams) {\n        applyQueryString(finalUrl, [{\n          \"rcb-scan\": 1,\n          \"rcb-scan-job\": id\n        }], true);\n      }\n      const link = `<a href=\"${url}\" target=\"_blank\">${url}</a>`;\n      try {\n        const {\n          ok,\n          status,\n          statusText,\n          type,\n          headers,\n          redirected,\n          url: responseUrl\n        } = await window.fetch(finalUrl.toString(), {\n          mode: \"no-cors\"\n        });\n        const isCors = type === \"opaque\";\n\n        // Check if page could be scanned successfully\n        if (redirected) {\n          // We cannot ensure 100% if this site got scanned successfully, let's do it again\n          executeThis(responseUrl);\n        } else if (ok ||\n        // See https://developer.mozilla.org/en-US/docs/Web/API/Response/type\n        // We should definitely ignore CORS\n        isCors) {\n          // Immediate update the status to show at least \"1 %\" in tab\n          if (group_uuid && (group_position === group_total || group_position === 1)) {\n            fetchStatus(true);\n          }\n\n          // A cors request never can mark the job as complete, we need to manually do this\n          if (isCors) {\n            await saveJobResult(id, process_total);\n          }\n\n          // We requested a file (what does this do in our sitemap? Just ignore)\n          const contentType = headers.get(\"content-type\")?.toLowerCase();\n          if (contentType && !contentType.startsWith(\"text/\")) {\n            await saveJobResult(id, process_total);\n          }\n          resolve();\n        } else if (status === 404) {\n          // We request a site which does no longer exist (perhaps not deleted from sitemap?) -> ignore\n          await saveJobResult(id, process_total);\n        } else {\n          reject({\n            code: `invalid_response_${status}`,\n            message: `${statusText} (${link})`\n          });\n        }\n      } catch (e) {\n        reject({\n          code: \"unexpected\",\n          message: `${e.toString()} (${link})`\n        });\n      }\n    };\n    executeThis(url);\n  });\n}\nexport { listenScannerJobExecution };","import { STATUS_ADDITIONAL_DATA_EVENT, STATUS_EVENT } from \"@devowl-wp/real-queue\";\nimport { SCAN_QUEUE_JOB } from \"../../types\";\nimport { __ } from \"../../utils\";\nimport $ from \"jquery\";\n/**\n * Add listener for the scanner status and automatically update the UI.\n */\nfunction listenScannerStatus() {\n  const adminBarNoticeElement = document.getElementById(\"rcb-scan-result-notice\");\n  const adminBarNoticeCounterElement = document.querySelector(\"#wp-admin-bar-rcb-scanner-found-services > a > span:nth-child(2)\");\n  let fetchAdditionalData = false;\n\n  // Always refresh notice in admin bar with results\n  document.addEventListener(STATUS_ADDITIONAL_DATA_EVENT, async _ref => {\n    let {\n      detail: {\n        settings: {\n          additionalData\n        }\n      }\n    } = _ref;\n    if (adminBarNoticeElement && fetchAdditionalData) {\n      additionalData.push(\"rcb-scan-notice\");\n    }\n  });\n  document.addEventListener(STATUS_EVENT, _ref2 => {\n    let {\n      detail: {\n        currentJobs: {\n          [SCAN_QUEUE_JOB]: currentJob\n        },\n        remaining: {\n          [SCAN_QUEUE_JOB]: remainingArr\n        },\n        additionalData: {\n          \"rcb-scan-notice\": rcbScanNotice\n        }\n      }\n    } = _ref2;\n    let percent = 100;\n    const hasFailureJobs = remainingArr?.[\"failure\"] > 0;\n\n    // Only show the badge for full scans\n    if (remainingArr && currentJob?.group_position > 0) {\n      const {\n        remaining,\n        total\n      } = remainingArr;\n      percent = +((total - remaining) / total * 100).toFixed(0);\n    }\n    const nowVisible = percent > 0 && percent < 100;\n    const statusElement = document.getElementById(\"rcb-scanner-status\");\n    const checklistExclamationMark = document.getElementById(\"rcb-checklist-overdue\");\n    fetchAdditionalData = nowVisible;\n\n    // Update admin bar notice\n    if (adminBarNoticeElement && rcbScanNotice) {\n      adminBarNoticeElement.innerHTML = rcbScanNotice.text;\n      adminBarNoticeCounterElement.innerHTML = adminBarNoticeCounterElement.innerHTML.replace(/\\d+/, rcbScanNotice.countAll.toString());\n    }\n    if (statusElement) {\n      const previousVisible = statusElement.style.display !== \"none\";\n      statusElement.innerHTML = `${percent} %`;\n      statusElement.style.display = nowVisible ? \"inline-block\" : \"none\";\n\n      // Hide checklist overdue when scanner is active\n      if (checklistExclamationMark) {\n        checklistExclamationMark.style.display = !nowVisible ? \"inline-block\" : \"none\";\n      }\n\n      // Show message that it has finished\n      if (previousVisible && !nowVisible && !hasFailureJobs) {\n        try {\n          // Show for \"Scanner\" tab when active, or show on \"Cookies\" menu item when not in config page\n          const $handle = $(['#real-cookie-banner-component .nav-tab[href=\"#/scanner\"]:not(.nav-tab-active)', '#real-cookie-banner-pro-component .nav-tab[href=\"#/scanner\"]:not(.nav-tab-active)', \"body:not(.toplevel_page_real-cookie-banner-component) #toplevel_page_real-cookie-banner-component\", \"body:not(.toplevel_page_real-cookie-banner-pro-component) #toplevel_page_real-cookie-banner-pro-component\"].join(\",\"));\n          const isNavTab = $handle.hasClass(\"nav-tab\");\n          $handle.pointer({\n            content: `<h3>${__(\"Real Cookie Banner has scanned your website!\")}</h3><p>${__('You may not have noticed, but we have been scanning your website in the background. View <a href=\"%s\">scanner results</a> to obtain consent for used services from your website visitors!', `${isNavTab ? \"\" : $handle.find(\"a\").attr(\"href\")}#/scanner`)}</p>`,\n            position: isNavTab ? {\n              edge: \"top\"\n            } : {\n              edge: \"left\",\n              align: \"bottom\"\n            },\n            pointerClass: `wp-pointer arrow-${isNavTab ? \"top\" : \"bottom\"}`,\n            pointerWidth: 420\n          });\n          const widget = $handle.pointer(\"widget\");\n          widget.css({\n            marginLeft: -10\n          });\n          if (isNavTab) {\n            widget.find(\".wp-pointer-arrow\").css({\n              marginLeft: -38\n            });\n          }\n          $handle.pointer(\"open\");\n          if (isNavTab) {\n            $handle.add(widget.find(\"a\")).on(\"click\", () => {\n              $handle.pointer(\"destroy\");\n            });\n          }\n        } catch (e) {\n          // jQuery or WP Pointer not available, but this does not matter\n        }\n      }\n    }\n  });\n}\nexport { listenScannerStatus };","import { CLIENT_JOB_EVENT_PREFIX } from \"@devowl-wp/real-queue\";\nimport { AUTOMATIC_SCAN_STATER_QUEUE_JOB } from \"../../types\";\nimport { refreshQueue, fetchStatus } from \"@devowl-wp/real-queue\";\nimport { locationRestScannerQueuePost } from \"../../wp-api\";\nimport { commonRequest } from \"@devowl-wp/utils\";\nimport { crawlSitemap } from \"./crawlSitemap\";\n\n/**\n * Add listener for the automatic scan starter.\n */\nfunction listenAutomaticScanStarterJobExecution() {\n  document.addEventListener(`${CLIENT_JOB_EVENT_PREFIX}${AUTOMATIC_SCAN_STATER_QUEUE_JOB}`, async _ref => {\n    let {\n      detail: {\n        job: {\n          id,\n          process_total\n        },\n        resolve,\n        // reject,\n        saveJobResult\n      }\n    } = _ref;\n    // Hide scan button in scanner tab\n    let scanButton;\n\n    // Periodically check for the scan button and hide it\n    const interval = setInterval(() => {\n      scanButton = document.getElementById(\"rcb-btn-scan-start\");\n      if (scanButton) {\n        scanButton.style.display = \"none\";\n      }\n    }, 1000);\n    try {\n      const sites = await crawlSitemap();\n\n      // Hacky get the REST options for `@devowl-wp/real-queue` as we have not\n      // RCB options available on all pages\n      const {\n        restRoot,\n        restNonce,\n        restQuery\n      } = window[\"realQueue\"];\n      const restNamespace = \"real-cookie-banner/v1\";\n      const options = {\n        restRoot,\n        restNamespace,\n        restNonce,\n        restQuery\n      };\n      await commonRequest({\n        location: locationRestScannerQueuePost,\n        options,\n        request: {\n          urls: sites,\n          purgeUnused: true\n        }\n      });\n      await refreshQueue();\n      fetchStatus(true);\n    } catch (e) {\n      // reject({ code: \"rcb_sitemap_crawl\", message: e.message }); // See below\n    } finally {\n      clearInterval(interval);\n      if (scanButton) {\n        scanButton.style.removeProperty(\"display\");\n      }\n\n      // Currently, we do not care about errors for the automatic starter\n      await saveJobResult(id, process_total);\n      resolve();\n    }\n  });\n}\nexport { listenAutomaticScanStarterJobExecution };"],"names":["__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","devowlWp_utils","devowlWp_realQueue","SCAN_QUEUE_JOB","FACTORY_MEMO","createLocalizationFactory","BaseOptions","__","arguments","jQuery","locationRestScannerQueuePost","path","method","RouteHttpVerb","REGEXP_URL_PATH","mapUrlToRootUrl","rootUrl","receivedUrl","query","length","undefined","rootUrlPath","match","receivedQuery","useQuery","substr","async","findByRobots","url","forceSitemapArgument","response","fetch","ok","correctedSitemapUrl","text","trim","responseCheckSitemap","body","test","e","KNOWN_FILENAMES","findByKnownFilenames","root","tryKnownFilenames","promises","map","filename","mode","promise","responseBody","indexOf","PSEUDO_URL_BASE","crawl","sitemapUrl","sites","document","DOMParser","parseFromString","parse","protocol","sitemapProtocol","URL","sitemapIndex","querySelector","indexUrls","Array","from","children","c","textContent","filter","Boolean","indexUrl","useUrl","urlSet","urls","urlInstance","toString","push","console","error","sort","b","crawlSitemap","setStep","textOfferSupport","window","realCookieBannerQueue","originalHomeUrl","split","Promise","resolve","reject","resolver","result","setTimeout","robotsTxt","byKnownFilenames","robotsTxtForce","byKnownFilenamesCustom","findSitemap","Error","handleCorruptRestApi","addEventListener","JOB_DELAY_EVENT_PREFIX","_ref","detail","isIdle","settings","isInScannerTab","location","href","delay_ms","CLIENT_JOB_EVENT_PREFIX","_ref2","job","id","data","process_total","group_position","group_total","group_uuid","saveJobResult","executeThis","finalUrl","searchParams","applyQueryString","link","status","statusText","type","headers","redirected","responseUrl","isCors","fetchStatus","contentType","toLowerCase","startsWith","code","message","adminBarNoticeElement","getElementById","adminBarNoticeCounterElement","fetchAdditionalData","STATUS_ADDITIONAL_DATA_EVENT","additionalData","STATUS_EVENT","currentJobs","currentJob","remaining","remainingArr","rcbScanNotice","percent","hasFailureJobs","total","toFixed","nowVisible","statusElement","checklistExclamationMark","innerHTML","replace","countAll","previousVisible","style","display","$handle","join","isNavTab","hasClass","pointer","content","find","attr","position","edge","align","pointerClass","pointerWidth","widget","css","marginLeft","add","on","listenScannerStatus","scanButton","interval","setInterval","restRoot","restNonce","restQuery","options","restNamespace","commonRequest","request","purgeUnused","refreshQueue","clearInterval","removeProperty"],"sourceRoot":""}